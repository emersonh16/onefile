<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Derelict Drifters — Beam + Miasma Grid + Sparkle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #0c0b10; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    // -----------------------------
    // CONFIG
    // -----------------------------
    const CONFIG = {
      playerRadius: 18,
      moveSpeed: 240,

      // Visual grid
      gridSize: 64,
      gridColor: "rgba(255,255,255,0.06)",
      bgColor: "#0c0b10",

      // Player look
      playerFill: "#f5f5f5",
      playerOutline: "rgba(0,0,0,0.35)",

      // Beam core
      beamRange: 260,
      coneRangeMin: 160,
      beamHalfAngleDeg: 22,
      beamHalfAngleMin: 4,
      beamHalfAngleMax: 90,
      wheelStepDeg: 6,

      // Visuals
      beamFill: "rgba(0, 255, 255, 0.18)",
      beamEdge: "rgba(0, 220, 255, 0.85)",
      beamEdgeWidth: 2,

      // Laser look (beefed up)
      laserWidth: 5,
      laserGlowWidth: 14,
      laserGlowAlpha: 0.25,

      // Sparkle
      sparkleSize: 12,
      sparkleAlpha: 0.9,

      // Bubble specifics
      bubbleRMax: 120,
      bubbleEdgeWidth: 2,
      bubbleFill: "rgba(0, 255, 220, 0.14)",
      bubbleEdge: "rgba(0, 220, 200, 0.9)",

      // Mode thresholds
      laserTotalDeg: 8,
      bubbleTotalDeg: 120,

      // Miasma grid
      tile: 8,   // new standard pixel size
      groundColor: "#3c4630",
      miasmaColor: "rgba(180,0,255,0.85)"
    };

    // -----------------------------
    // Canvas
    // -----------------------------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false });
    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    // -----------------------------
    // State
    // -----------------------------
    const state = {
      time: 0, dt: 0,
      keys: Object.create(null),
      cam: { x: 0, y: 0 },
      mouse: { x: 0, y: 0, worldX: 0, worldY: 0 },
      beam: {
        on: true,
        halfAngle: toRad(CONFIG.beamHalfAngleDeg),
        aimAngle: 0,
        mode: "cone",
        bubbleR: CONFIG.bubbleRMax,
        effectiveRange: CONFIG.beamRange
      },
      cols: 200,
      rows: 200,
      miasma: null
    };
    state.miasma = new Uint8Array(state.cols * state.rows).fill(1);

    // -----------------------------
    // Input
    // -----------------------------
    window.addEventListener("keydown", (e) => { state.keys[e.key.toLowerCase()] = true; });
    window.addEventListener("keyup", (e) => { state.keys[e.key.toLowerCase()] = false; });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      state.mouse.x = e.clientX - rect.left;
      state.mouse.y = e.clientY - rect.top;
      state.mouse.worldX = state.mouse.x + (state.cam.x - canvas.width / 2);
      state.mouse.worldY = state.mouse.y + (state.cam.y - canvas.height / 2);
      const cx = canvas.width / 2, cy = canvas.height / 2;
      state.beam.aimAngle = Math.atan2(state.mouse.y - cy, state.mouse.x - cx);
    });

    window.addEventListener("wheel", (e) => {
      const delta = Math.sign(e.deltaY);
      const step = toRad(CONFIG.wheelStepDeg);
      state.beam.halfAngle -= delta * step;
      state.beam.halfAngle = clamp(state.beam.halfAngle, toRad(CONFIG.beamHalfAngleMin), toRad(CONFIG.beamHalfAngleMax));
      e.preventDefault();
    }, { passive: false });

    // -----------------------------
    // Update
    // -----------------------------
 function update(dt) {
  let vx = 0, vy = 0;
  if (state.keys["w"]) vy -= 1;
  if (state.keys["s"]) vy += 1;
  if (state.keys["a"]) vx -= 1;
  if (state.keys["d"]) vx += 1;

  if (vx !== 0 || vy !== 0) {
    const len = Math.hypot(vx, vy);
    vx /= len; vy /= len;
  }

  state.cam.x += vx * CONFIG.moveSpeed * dt;
  state.cam.y += vy * CONFIG.moveSpeed * dt;

  // Beam mode + range mapping
  const totalDeg = toDeg(state.beam.halfAngle * 2);

  if (totalDeg <= CONFIG.laserTotalDeg) {
    state.beam.mode = "laser";
    state.beam.effectiveRange = CONFIG.beamRange;

  } else if (totalDeg >= CONFIG.bubbleTotalDeg) {
    state.beam.mode = "bubble";
    const maxTotal = CONFIG.beamHalfAngleMax * 2;
    const t = clamp((totalDeg - CONFIG.bubbleTotalDeg) / (maxTotal - CONFIG.bubbleTotalDeg), 0, 1);
    state.beam.bubbleR = CONFIG.bubbleRMax * (1 - t);

  } else {
    state.beam.mode = "cone";
    const t = clamp((totalDeg - CONFIG.laserTotalDeg) / (CONFIG.bubbleTotalDeg - CONFIG.laserTotalDeg), 0, 1);
    state.beam.effectiveRange = lerp(CONFIG.beamRange, CONFIG.coneRangeMin, t);
  }

  // -----------------------------
  // NEW: Clear miasma under the beam
  // -----------------------------
  clearMiasmaWithBeam();
}


    // -----------------------------
    // Draw world + miasma
    // -----------------------------
    function drawWorld() {
      const { tile, groundColor, miasmaColor } = CONFIG;
      const startCol = Math.floor((state.cam.x - canvas.width/2) / tile);
      const startRow = Math.floor((state.cam.y - canvas.height/2) / tile);
      const endCol = Math.floor((state.cam.x + canvas.width/2) / tile) + 1;
      const endRow = Math.floor((state.cam.y + canvas.height/2) / tile) + 1;

      for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
          const idx = ((row % state.rows + state.rows) % state.rows) * state.cols + ((col % state.cols + state.cols) % state.cols);
          const sx = col * tile - state.cam.x + canvas.width/2;
          const sy = row * tile - state.cam.y + canvas.height/2;

          ctx.fillStyle = groundColor;
          ctx.fillRect(sx, sy, tile, tile);

          if (state.miasma[idx] === 1) {
            ctx.fillStyle = miasmaColor;
            ctx.fillRect(sx, sy, tile, tile);
          }
        }
      }
    }

    function drawPlayer() {
      const cx = canvas.width / 2, cy = canvas.height / 2;
      ctx.beginPath();
      ctx.arc(cx, cy, CONFIG.playerRadius, 0, Math.PI * 2);
      ctx.fillStyle = CONFIG.playerFill;
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = CONFIG.playerOutline;
      ctx.stroke();
    }

    function drawBeam() {
      if (!state.beam.on) return;
      const cx = canvas.width/2, cy = canvas.height/2;
      const a = state.beam.aimAngle, ha = state.beam.halfAngle;

      if (state.beam.mode === "laser") {
        const r = state.beam.effectiveRange;
        const lx = cx + Math.cos(a) * r, ly = cy + Math.sin(a) * r;

        // Glow
        ctx.save();
        ctx.globalAlpha = CONFIG.laserGlowAlpha;
        ctx.lineWidth = CONFIG.laserGlowWidth;
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(lx, ly); ctx.stroke();
        ctx.restore();

        // Core
        ctx.lineWidth = CONFIG.laserWidth;
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(lx, ly); ctx.stroke();

        // Sparkle
        const time = state.time * 6;
        ctx.save();
        ctx.translate(lx, ly);
        ctx.rotate(time * 0.5);
        ctx.globalAlpha = CONFIG.sparkleAlpha * (0.7 + 0.3 * Math.sin(time));
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI / 3);
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * CONFIG.sparkleSize, Math.sin(angle) * CONFIG.sparkleSize);
        }
        ctx.stroke();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = CONFIG.beamEdge;
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return;
      }

      if (state.beam.mode === "bubble") {
        const br = state.beam.bubbleR; if (br <= 0.5) return;
        ctx.beginPath(); ctx.arc(cx, cy, br, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.bubbleFill; ctx.fill();
        ctx.lineWidth = CONFIG.bubbleEdgeWidth;
        ctx.strokeStyle = CONFIG.bubbleEdge; ctx.stroke();
        return;
      }

      // Cone
      const r = state.beam.effectiveRange, a0 = a - ha, a1 = a + ha;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, a0, a1);
      ctx.closePath(); ctx.fillStyle = CONFIG.beamFill; ctx.fill();
      ctx.lineWidth = CONFIG.beamEdgeWidth; ctx.strokeStyle = CONFIG.beamEdge;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a0)*r, cy + Math.sin(a0)*r);
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a1)*r, cy + Math.sin(a1)*r);
      ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, r, a0, a1); ctx.stroke();
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px monospace"; ctx.textBaseline = "top";
      const fps = Math.round(1 / Math.max(0.0001, state.dt));
      const totalDeg = toDeg(state.beam.halfAngle * 2);
      ctx.fillText(`FPS: ${fps}`, 8, 8);
      ctx.fillText(`CAM: (${state.cam.x.toFixed(1)}, ${state.cam.y.toFixed(1)})`, 8, 24);
      let mode = state.beam.mode.toUpperCase(), extra="";
      if (mode==="BUBBLE") extra=` | R=${Math.max(0, state.beam.bubbleR).toFixed(0)}`;
      if (mode==="CONE")   extra=` | range=${state.beam.effectiveRange.toFixed(0)}`;
      if (mode==="LASER")  extra=` | range=${state.beam.effectiveRange.toFixed(0)}`;
      ctx.fillText(`Mode: ${mode} | width=${totalDeg.toFixed(0)}°${extra}`, 8, 40);
      ctx.fillText(`Wheel: width +/- ${CONFIG.wheelStepDeg}° per step`, 8, 56);
    }

    // -----------------------------
    // Main loop
    // -----------------------------
    let last = performance.now();
    function loop(now) {
      state.dt = (now - last) / 1000; last = now;
      state.time += state.dt;
      update(state.dt);
      ctx.fillStyle = CONFIG.bgColor; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawWorld();
      drawBeam();
      drawPlayer();
      drawHUD();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // -----------------------------
    // Utils
    // -----------------------------
    function clamp(v,lo,hi){ return Math.max(lo,Math.min(hi,v)); }
    function toRad(deg){ return deg*Math.PI/180; }
    function toDeg(rad){ return rad*180/Math.PI; }
    function lerp(a,b,t){ return a+(b-a)*t; }

    // -----------------------------
// Beam Hitbox + Collision Helpers
// -----------------------------
function getBeamHitbox() {
  const cx = canvas.width/2, cy = canvas.height/2;
  const a = state.beam.aimAngle, ha = state.beam.halfAngle;

  if (state.beam.mode === "laser") {
    const r = state.beam.effectiveRange;
    const lx = cx + Math.cos(a) * r;
    const ly = cy + Math.sin(a) * r;
    return {
      type: "line",
      x1: cx, y1: cy,
      x2: lx, y2: ly,
      radius: CONFIG.laserGlowWidth * 1 // chunky thickness
    };
  }

  if (state.beam.mode === "bubble") {
    return { type:"circle", x:cx, y:cy, r: state.beam.bubbleR };
  }

  if (state.beam.mode === "cone") {
    const r = state.beam.effectiveRange;
    return { type:"cone", x:cx, y:cy, r, a0: a - ha, a1: a + ha };
  }
}

// distance check for points
function pointInBeam(x, y) {
  const hb = getBeamHitbox();
  if (!hb) return false;

  if (hb.type === "circle") {
    return ( (x-hb.x)**2 + (y-hb.y)**2 <= hb.r**2 );
  }

  if (hb.type === "line") {
    const dx = hb.x2 - hb.x1, dy = hb.y2 - hb.y1;
    const t = Math.max(0, Math.min(1, ((x-hb.x1)*dx + (y-hb.y1)*dy) / (dx*dx+dy*dy)));
    const px = hb.x1 + t*dx, py = hb.y1 + t*dy;
    const dist2 = (x-px)**2 + (y-py)**2;
    return dist2 <= hb.radius**2;
  }

  if (hb.type === "cone") {
    const dx = x - hb.x, dy = y - hb.y;
    const dist2 = dx*dx + dy*dy;
    if (dist2 > hb.r*hb.r) return false;
    const ang = Math.atan2(dy, dx);
    let diff = ang - hb.a0;
    while (diff < 0) diff += Math.PI*2;
    const arc = (hb.a1 - hb.a0 + Math.PI*2) % (Math.PI*2);
    return diff <= arc;
  }
}

// clears tiles under the beam
function clearMiasmaWithBeam() {
  const hb = getBeamHitbox();
  if (!hb) return;

  const { tile } = CONFIG;
  const startCol = Math.floor((state.cam.x - canvas.width/2) / tile);
  const startRow = Math.floor((state.cam.y - canvas.height/2) / tile);
  const endCol = Math.floor((state.cam.x + canvas.width/2) / tile) + 1;
  const endRow = Math.floor((state.cam.y + canvas.height/2) / tile) + 1;

  for (let row = startRow; row <= endRow; row++) {
    for (let col = startCol; col <= endCol; col++) {
      const idx = ((row % state.rows + state.rows) % state.rows) * state.cols +
                  ((col % state.cols + state.cols) % state.cols);
      const cx = col * tile - state.cam.x + canvas.width/2 + tile/2;
      const cy = row * tile - state.cam.y + canvas.height/2 + tile/2;
      if (pointInBeam(cx, cy)) {
        state.miasma[idx] = 0; // clear tile
      }
    }
  }
}

  </script>
</body>
</html>
