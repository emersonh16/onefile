<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Derelict Drifters — Conveyor Miasma Sheet (Visual Only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #0c0b10; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    // --------------------------------------------------
    // CONFIG — easy knobs
    // --------------------------------------------------
    const CONFIG = {
      // World
      worldRadius: 600,              // circle radius (world px)
      bgColor: "#0c0b10",
      groundColor: "#3c4630",

      // Fog pixels
      tile: 4,                       // 1 fog pixel = 4x4 world px

      // Conveyor sheet sizing
      beltLengthFactor: 4.0,         // length = factor * worldDiameter
      patchDensity: 0.00035,         // blobs per fog pixel (belt area)
      patchRadiusMin: 16,            // in fog pixels
      patchRadiusMax: 40,
      miasmaColorRGBA: [180, 0, 255, Math.round(0.92 * 255)],

      // Belt visuals
      showBeltBorder: true,
      beltBorderColor: "magenta",
      beltBorderWidth: 3,

      // Camera move (so you can pan around)
      moveSpeed: 240,

      // Wind (in fog pixels per second)
      windSpeedMin: 35,
      windSpeedMax: 90,
      windEase: 1.5,                 // current→target follow (per second)
      windRetargetEvery: 12,         // small turns
      gustIntervalMin: 22,
      gustIntervalMax: 40,
      gustAngleMinDeg: 90,
      gustSpeedBoost: 2.2,

      // Belt swivel easing
      angleEase: 2.0,                // how quickly belt rotates toward wind dir (per second)

      // RNG seed (so blobs stay stable on reload)
      seed: 1337
    };

    // --------------------------------------------------
    // Canvas
    // --------------------------------------------------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false });
    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    // --------------------------------------------------
    // Derived sizes
    // --------------------------------------------------
    const worldDiameter = CONFIG.worldRadius * 2;
    const beltWorldWidth  = worldDiameter;                         // EXACTLY world width
    const beltWorldLength = Math.max(beltWorldWidth * CONFIG.beltLengthFactor, beltWorldWidth + 1);

    const beltFogWidth  = Math.ceil(beltWorldWidth  / CONFIG.tile);
    const beltFogLength = Math.ceil(beltWorldLength / CONFIG.tile);

    // --------------------------------------------------
    // State
    // --------------------------------------------------
    const state = {
      time: 0, dt: 0,
      keys: Object.create(null),
      cam: { x: 0, y: 0 },              // world-space camera center

      // Wind vectors (fog px/s)
      wind: { vx: 0, vy: 0 },
      windTarget: { vx: 0, vy: 0 },
      smallTurnTimer: 0,
      gustTimer: 0,
      nextGustAt: 0,

      // Belt (conveyor)
      belt: {
        angle: 0,                       // current orientation (radians)
        offsetWorld: 0,                 // slide along long axis (world px, wrapped)
      },

      // Offscreen belt texture (in fog pixels)
      beltCanvas: null,
      beltCtx: null,
      beltImageData: null
    };

    // --------------------------------------------------
    // Input
    // --------------------------------------------------
    window.addEventListener("keydown", e => state.keys[e.key.toLowerCase()] = true);
    window.addEventListener("keyup",   e => state.keys[e.key.toLowerCase()] = false);

    // --------------------------------------------------
    // RNG (mulberry32)
    // --------------------------------------------------
    function mulberry32(a){ return function(){let t=a+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
    const rand = mulberry32(CONFIG.seed|0);
    function randRange(a,b){ return a + (b-a) * rand(); }
    function randInt(a,b){ return Math.floor(randRange(a, b+1)); }

    // --------------------------------------------------
    // Init belt texture
    // --------------------------------------------------
    initBelt();

    function initBelt() {
      state.beltCanvas = document.createElement('canvas');
      state.beltCanvas.width  = beltFogWidth;
      state.beltCanvas.height = beltFogLength;
      state.beltCtx = state.beltCanvas.getContext('2d', { alpha: true });
      state.beltImageData = state.beltCtx.createImageData(beltFogWidth, beltFogLength);

      // Start fully clear
      const data = state.beltImageData.data;
      for (let i = 0; i < beltFogWidth * beltFogLength; i++) {
        const idx = i*4; data[idx]=0; data[idx+1]=0; data[idx+2]=0; data[idx+3]=0;
      }

      // Stamp round blobs into the rectangular sheet (clipped by edges)
      const area = beltFogWidth * beltFogLength;
      const count = Math.max(1, Math.floor(area * CONFIG.patchDensity));
      const [mr, mg, mb, ma] = CONFIG.miasmaColorRGBA;

      for (let p = 0; p < count; p++) {
        const r  = randInt(CONFIG.patchRadiusMin, CONFIG.patchRadiusMax);
        const cx = randInt(-r, beltFogWidth  + r);
        const cy = randInt(-r, beltFogLength + r);
        const r2 = r*r;

        const y0 = Math.max(0, cy - r), y1 = Math.min(beltFogLength - 1, cy + r);
        for (let y = y0; y <= y1; y++) {
          const dy = y - cy;
          const dxMax = Math.floor(Math.sqrt(Math.max(0, r2 - dy*dy)));
          const x0 = Math.max(0, cx - dxMax), x1 = Math.min(beltFogWidth - 1, cx + dxMax);
          for (let x = x0; x <= x1; x++) {
            const idx = (y * beltFogWidth + x) * 4;
            data[idx+0] = mr; data[idx+1] = mg; data[idx+2] = mb; data[idx+3] = ma;
          }
        }
      }

      state.beltCtx.putImageData(state.beltImageData, 0, 0);
    }

    // --------------------------------------------------
    // Wind helpers
    // --------------------------------------------------
    function setWindTarget(angle = Math.random() * Math.PI * 2, speed = randRange(CONFIG.windSpeedMin, CONFIG.windSpeedMax)) {
      state.windTarget.vx = Math.cos(angle) * speed;
      state.windTarget.vy = Math.sin(angle) * speed;
    }
    function scheduleNextGust() {
      state.nextGustAt = randRange(CONFIG.gustIntervalMin, CONFIG.gustIntervalMax);
      state.gustTimer = 0;
    }
    setWindTarget();    // initial
    scheduleNextGust();

    // --------------------------------------------------
    // Main loop
    // --------------------------------------------------
    let last = performance.now();
    requestAnimationFrame(loop);
    function loop(now) {
      state.dt = (now - last) / 1000; last = now;
      state.time += state.dt;

      update(state.dt);
      draw();

      requestAnimationFrame(loop);
    }

    // --------------------------------------------------
    // Update
    // --------------------------------------------------
    function update(dt) {
      // Camera pan (inside the demo circle)
      let vx = 0, vy = 0;
      if (state.keys["w"]) vy -= 1;
      if (state.keys["s"]) vy += 1;
      if (state.keys["a"]) vx -= 1;
      if (state.keys["d"]) vx += 1;
      if (vx || vy) { const L = Math.hypot(vx, vy); vx /= L; vy /= L; }
      state.cam.x += vx * CONFIG.moveSpeed * dt;
      state.cam.y += vy * CONFIG.moveSpeed * dt;

      const d = Math.hypot(state.cam.x, state.cam.y);
      if (d > CONFIG.worldRadius) {
        const s = CONFIG.worldRadius / d;
        state.cam.x *= s; state.cam.y *= s;
      }

      // Wind retarget / gusts
      state.smallTurnTimer += dt;
      state.gustTimer += dt;

      if (state.smallTurnTimer >= CONFIG.windRetargetEvery) {
        state.smallTurnTimer = 0;
        const curAng = Math.atan2(state.windTarget.vy, state.windTarget.vx);
        const smallDelta = randRange(-Math.PI/6, Math.PI/6);
        const newAng = curAng + smallDelta;
        const newSpeed = clamp(
          Math.hypot(state.windTarget.vx, state.windTarget.vy) + randRange(-8, 8),
          CONFIG.windSpeedMin,
          CONFIG.windSpeedMax
        );
        setWindTarget(newAng, newSpeed);
      }

      if (state.gustTimer >= state.nextGustAt) {
        scheduleNextGust();
        const curAng = Math.atan2(state.wind.vy, state.wind.vx);
        const turn = toRad(randRange(CONFIG.gustAngleMinDeg, 180)) * (Math.random() < 0.5 ? -1 : 1);
        const newAng = curAng + turn;
        const base = randRange(CONFIG.windSpeedMin, CONFIG.windSpeedMax);
        const boosted = Math.min(base * CONFIG.gustSpeedBoost, CONFIG.windSpeedMax);
        setWindTarget(newAng, boosted);
      }

      // Ease current wind toward target
      const k = Math.min(1, CONFIG.windEase * dt);
      state.wind.vx += (state.windTarget.vx - state.wind.vx) * k;
      state.wind.vy += (state.windTarget.vy - state.wind.vy) * k;

      // Swivel belt to face wind direction (ease angle)
      const targetAngle = Math.atan2(state.wind.vy, state.wind.vx);
      state.belt.angle = lerpAngle(state.belt.angle, targetAngle, Math.min(1, CONFIG.angleEase * dt));

      // Slide belt along its long axis at the wind's component along that axis
      const beltDir = { x: Math.cos(state.belt.angle), y: Math.sin(state.belt.angle) }; // long axis
      const windAlong = state.wind.vx * beltDir.x + state.wind.vy * beltDir.y;          // fog px/s
      const scrollWorld = windAlong * CONFIG.tile * dt;                                  // world px
      state.belt.offsetWorld = mod(state.belt.offsetWorld + scrollWorld, beltWorldLength);
    }

    // --------------------------------------------------
    // Draw
    // --------------------------------------------------
    function draw() {
      // Clear bg
      ctx.fillStyle = CONFIG.bgColor;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Ground (only inside the world circle to make the outside obvious)
      ctx.save();
      ctx.beginPath();
      ctx.arc(canvas.width/2 - state.cam.x, canvas.height/2 - state.cam.y, CONFIG.worldRadius, 0, Math.PI*2);
      ctx.clip();

      const worldLeft = -CONFIG.worldRadius - state.cam.x + canvas.width/2;
      const worldTop  = -CONFIG.worldRadius - state.cam.y + canvas.height/2;
      const worldSize = CONFIG.worldRadius * 2;
      ctx.fillStyle = CONFIG.groundColor;
      ctx.fillRect(worldLeft, worldTop, worldSize, worldSize);
      ctx.restore();

      // Draw the conveyor belt (not clipped, so you can see it outside the circle)
      drawBelt();

      // World ring
      ctx.beginPath();
      ctx.arc(canvas.width/2 - state.cam.x, canvas.height/2 - state.cam.y, CONFIG.worldRadius, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 4;
      ctx.stroke();

      // HUD
      drawHUD();
    }

    function drawBelt() {
      const cx = canvas.width/2 - state.cam.x;
      const cy = canvas.height/2 - state.cam.y;

      const hw = beltWorldWidth  / 2;
      const hl = beltWorldLength / 2;

      // Convert offset to fog pixels for source slicing
      const offsetFog = Math.floor((state.belt.offsetWorld / CONFIG.tile) % beltFogLength);
      const segA_FogH = beltFogLength - offsetFog;
      const segB_FogH = offsetFog;

      const segA_WorldH = segA_FogH * CONFIG.tile;
      const segB_WorldH = segB_FogH * CONFIG.tile;

      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(state.belt.angle);
      ctx.imageSmoothingEnabled = false;

      // Segment A: source from [0 .. width] x [offset .. end] → dest top half
      if (segA_FogH > 0) {
        ctx.drawImage(
          state.beltCanvas,
          0, offsetFog,               // sx, sy
          beltFogWidth, segA_FogH,    // sWidth, sHeight
          -hw, -hl,                   // dx, dy (top-left of belt)
          beltWorldWidth, segA_WorldH // dWidth, dHeight
        );
      }
      // Segment B: wrap from top of source to fill the bottom
      if (segB_FogH > 0) {
        ctx.drawImage(
          state.beltCanvas,
          0, 0,
          beltFogWidth, segB_FogH,
          -hw, -hl + segA_WorldH,
          beltWorldWidth, segB_WorldH
        );
      }

      // Border
      if (CONFIG.showBeltBorder) {
        ctx.strokeStyle = CONFIG.beltBorderColor;
        ctx.lineWidth = CONFIG.beltBorderWidth;
        ctx.strokeRect(-hw, -hl, beltWorldWidth, beltWorldLength);
      }

      ctx.restore();
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px monospace";
      ctx.textBaseline = "top";

      const fps = Math.round(1 / Math.max(0.0001, state.dt));
      const windSpd = Math.hypot(state.wind.vx, state.wind.vy);
      const windAng = toDeg(Math.atan2(state.wind.vy, state.wind.vx));
      const beltAng = toDeg(state.belt.angle);

      ctx.fillText(`FPS: ${fps}`, 8, 8);
      ctx.fillText(`Wind: ${windSpd.toFixed(1)} px/s @ ${((windAng+360)%360).toFixed(0)}°`, 8, 24);
      ctx.fillText(`Belt: angle ${((beltAng+360)%360).toFixed(0)}°  offset ${state.belt.offsetWorld.toFixed(1)}px`, 8, 40);
      ctx.fillText(`Belt size: ${beltWorldWidth}×${beltWorldLength} (world px)`, 8, 56);
    }

    // --------------------------------------------------
    // Utils
    // --------------------------------------------------
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function toRad(deg){ return deg * Math.PI / 180; }
    function toDeg(rad){ return rad * 180 / Math.PI; }
    function mod(n, m){ return ((n % m) + m) % m; }
    function lerpAngle(a, b, t) {
      // shortest-path blend
      let d = ((b - a + Math.PI*3) % (Math.PI*2)) - Math.PI;
      return a + d * t;
    }
  </script>
</body>
</html>
