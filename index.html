<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Derelict Drifters — Evident Miasma (Seamless Wrap)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background: #0c0b10; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    // ---------------------------------------
    // CONFIG (easy knobs)
    // ---------------------------------------
    const CONFIG = {
      // Player + world
      playerRadius: 18,
      moveSpeed: 240,
      bgColor: "#0c0b10",
      groundColor: "#3c4630",
      worldRadius: 600,         // circular world radius (world px)

      // Pixel grid
      tile: 4,                  // fog pixel -> rendered as 4x4 world px

      // Beam core + visuals
      beamRange: 260,
      coneRangeMin: 160,
      beamHalfAngleDeg: 22,
      beamHalfAngleMin: 4,
      beamHalfAngleMax: 90,
      wheelStepDeg: 6,

      beamFill: "rgba(0, 255, 255, 0.18)",
      beamEdge: "rgba(0, 220, 255, 0.85)",
      beamEdgeWidth: 2,
      laserWidth: 5,
      laserGlowWidth: 14,
      laserGlowAlpha: 0.25,
      sparkleSize: 12,
      sparkleAlpha: 0.9,

      bubbleRMax: 120,
      bubbleEdgeWidth: 2,
      bubbleFill: "rgba(0, 255, 220, 0.14)",
      bubbleEdge: "rgba(0, 220, 200, 0.9)",

      laserTotalDeg: 8,
      bubbleTotalDeg: 120,

      // Miasma color (RGBA bytes) — HIGHER ALPHA so it's really visible
      miasmaColorRGBA: [180, 0, 255, Math.round(0.92 * 255)],

      // --- Cloud sheet (finite) ---
      sheetScale: 2.2,          // sheet size relative to world diameter
      patchCount: 48,           // DENSE for obviousness; tune down later
      patchRadiusMin: 28,       // in fog pixels
      patchRadiusMax: 56,

      // --- Wind behavior (fog px / s)
      windSpeedMin: 40,
      windSpeedMax: 80,
      windEase: 1.5,            // how fast current wind follows target (per second)
      windRetargetEvery: 14,    // small drift retarget (gentle turns)
      gustIntervalMin: 32,      // dramatic & rare
      gustIntervalMax: 55,
      gustAngleMinDeg: 120,
      gustSpeedBoost: 1.6,

      // Respawn
      spawnMargin: 120,

      // --- Debug helpers ---
      debug: {
        alwaysCenterSpawn: true,
        showSheetBounds: false   // <— turned OFF (no magenta box)
      }
    };

    // ---------------------------------------
    // Canvas
    // ---------------------------------------
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false });
    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------------------------------------
    // State
    // ---------------------------------------
    const state = {
      time: 0, dt: 0,
      keys: Object.create(null),
      cam: { x: 0, y: 0 },                      // world coords of screen center
      mouse: { x: 0, y: 0, worldX: 0, worldY: 0 },
      beam: {
        on: true,
        halfAngle: toRad(CONFIG.beamHalfAngleDeg),
        aimAngle: 0,
        mode: "cone",
        bubbleR: CONFIG.bubbleRMax,
        effectiveRange: CONFIG.beamRange
      },

      // Wind
      wind: { vx: 0, vy: 0 },
      windTarget: { vx: 0, vy: 0 },
      smallTurnTimer: 0,
      gustTimer: 0,
      nextGustAt: 0,

      // Fog sheet (finite buffer, drawn tiled)
      sheet: null,              // {x,y,w,h}
      sheetCanvas: null,
      sheetCtx: null,
      sheetImageData: null
    };

    // ---------------------------------------
    // Derived sizes
    // ---------------------------------------
    const worldDiameter = CONFIG.worldRadius * 2;
    const worldFogSize = Math.ceil(worldDiameter / CONFIG.tile);     // in fog pixels
    const sheetFogSize = Math.ceil(worldFogSize * CONFIG.sheetScale);
    const sheetWorldSizePx = sheetFogSize * CONFIG.tile;

    // ---------------------------------------
    // Create initial fog sheet
    // ---------------------------------------
    createSheet(randomAngle());

    // ---------------------------------------
    // Input
    // ---------------------------------------
    window.addEventListener("keydown", (e) => { state.keys[e.key.toLowerCase()] = true; });
    window.addEventListener("keyup",   (e) => { state.keys[e.key.toLowerCase()] = false; });

    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      state.mouse.x = e.clientX - rect.left;
      state.mouse.y = e.clientY - rect.top;
      state.mouse.worldX = state.mouse.x + (state.cam.x - canvas.width / 2);
      state.mouse.worldY = state.mouse.y + (state.cam.y - canvas.height / 2);

      const cx = canvas.width / 2, cy = canvas.height / 2;
      state.beam.aimAngle = Math.atan2(state.mouse.y - cy, state.mouse.x - cx);
    });

    window.addEventListener("wheel", (e) => {
      const delta = Math.sign(e.deltaY);
      const step = toRad(CONFIG.wheelStepDeg);
      state.beam.halfAngle -= delta * step;
      state.beam.halfAngle = clamp(state.beam.halfAngle, toRad(CONFIG.beamHalfAngleMin), toRad(CONFIG.beamHalfAngleMax));
      e.preventDefault();
    }, { passive: false });

    // ---------------------------------------
    // Wind helpers
    // ---------------------------------------
    function setWindTarget(angle = randomAngle(), speed = randRange(CONFIG.windSpeedMin, CONFIG.windSpeedMax)) {
      state.windTarget.vx = Math.cos(angle) * speed;
      state.windTarget.vy = Math.sin(angle) * speed;
    }
    function scheduleNextGust() {
      state.nextGustAt = randRange(CONFIG.gustIntervalMin, CONFIG.gustIntervalMax);
      state.gustTimer = 0;
    }
    setWindTarget();      // initial small target
    scheduleNextGust();   // schedule first gust later

    // ---------------------------------------
    // Create a new fog sheet seeded with *patchy clouds*
    // ---------------------------------------
    function createSheet(incomingAngle) {
      // offscreen canvas for the sheet
      state.sheetCanvas = document.createElement('canvas');
      state.sheetCanvas.width = sheetFogSize;
      state.sheetCanvas.height = sheetFogSize;
      state.sheetCtx = state.sheetCanvas.getContext('2d', { alpha: true });
      state.sheetImageData = state.sheetCtx.createImageData(sheetFogSize, sheetFogSize);

      // start fully clear
      const img = state.sheetImageData.data;
      for (let i = 0; i < sheetFogSize * sheetFogSize; i++) {
        img[i*4 + 0] = 0;
        img[i*4 + 1] = 0;
        img[i*4 + 2] = 0;
        img[i*4 + 3] = 0;
      }

      // stamp patchy blobs (hard-edged circles for pixel style)
      const [mr, mg, mb, ma] = CONFIG.miasmaColorRGBA;
      const count = CONFIG.patchCount;
      for (let p = 0; p < count; p++) {
        const r  = randInt(CONFIG.patchRadiusMin, CONFIG.patchRadiusMax);
        const cx = randInt(r, sheetFogSize - r - 1);
        const cy = randInt(r, sheetFogSize - r - 1);
        const r2 = r * r;

        const y0 = Math.max(0, cy - r), y1 = Math.min(sheetFogSize - 1, cy + r);
        for (let y = y0; y <= y1; y++) {
          const dy = y - cy;
          const dxMax = Math.floor(Math.sqrt(Math.max(0, r2 - dy*dy)));
          const x0 = Math.max(0, cx - dxMax), x1 = Math.min(sheetFogSize - 1, cx + dxMax);
          for (let x = x0; x <= x1; x++) {
            const idx = (y * sheetFogSize + x) * 4;
            img[idx + 0] = mr;
            img[idx + 1] = mg;
            img[idx + 2] = mb;
            img[idx + 3] = ma; // alpha => visible
          }
        }
      }

      state.sheetCtx.putImageData(state.sheetImageData, 0, 0);

      // Spawn position (centered so you see it instantly)
      state.sheet = {
        x: -sheetWorldSizePx / 2,
        y: -sheetWorldSizePx / 2,
        w: sheetWorldSizePx,
        h: sheetWorldSizePx
      };
    }

    // ---------------------------------------
    // Update
    // ---------------------------------------
    function update(dt) {
      // Player movement
      let vx = 0, vy = 0;
      if (state.keys["w"]) vy -= 1;
      if (state.keys["s"]) vy += 1;
      if (state.keys["a"]) vx -= 1;
      if (state.keys["d"]) vx += 1;
      if (vx || vy) { const L = Math.hypot(vx, vy); vx /= L; vy /= L; }
      state.cam.x += vx * CONFIG.moveSpeed * dt;
      state.cam.y += vy * CONFIG.moveSpeed * dt;

      // Clamp camera to world circle
      const d = Math.hypot(state.cam.x, state.cam.y);
      if (d > CONFIG.worldRadius) {
        const s = CONFIG.worldRadius / d;
        state.cam.x *= s; state.cam.y *= s;
      }

      // Beam modes
      const totalDeg = toDeg(state.beam.halfAngle * 2);
      if (totalDeg <= CONFIG.laserTotalDeg) {
        state.beam.mode = "laser";
        state.beam.effectiveRange = CONFIG.beamRange;
      } else if (totalDeg >= CONFIG.bubbleTotalDeg) {
        state.beam.mode = "bubble";
        const maxTotal = CONFIG.beamHalfAngleMax * 2;
        const t = clamp((totalDeg - CONFIG.bubbleTotalDeg) / (maxTotal - CONFIG.bubbleTotalDeg), 0, 1);
        state.beam.bubbleR = CONFIG.bubbleRMax * (1 - t);
      } else {
        state.beam.mode = "cone";
        const t = clamp((totalDeg - CONFIG.laserTotalDeg) / (CONFIG.bubbleTotalDeg - CONFIG.laserTotalDeg), 0, 1);
        state.beam.effectiveRange = lerp(CONFIG.beamRange, CONFIG.coneRangeMin, t);
      }

      // --- Wind logic ---
      state.smallTurnTimer += dt;
      state.gustTimer += dt;

      // soft retarget occasionally (gentle)
      if (state.smallTurnTimer >= CONFIG.windRetargetEvery) {
        state.smallTurnTimer = 0;
        const curAng = Math.atan2(state.windTarget.vy, state.windTarget.vx);
        const smallDelta = randRange(-Math.PI/6, Math.PI/6); // +/- 30°
        const newAng = curAng + smallDelta;
        const newSpeed = clamp(
          Math.hypot(state.windTarget.vx, state.windTarget.vy) + randRange(-1, 1),
          CONFIG.windSpeedMin,
          CONFIG.windSpeedMax
        );
        setWindTarget(newAng, newSpeed);
      }

      // rare dramatic gust
      if (state.gustTimer >= state.nextGustAt) {
        state.gustTimer = 0;
        scheduleNextGust();

        // big angle swing
        const curAng = Math.atan2(state.wind.vy, state.wind.vx);
        const turn = toRad(randRange(CONFIG.gustAngleMinDeg, 180)) * (Math.random() < 0.5 ? -1 : 1);
        const newAng = curAng + turn;

        // spike speed
        const base = randRange(CONFIG.windSpeedMin, CONFIG.windSpeedMax);
        const boosted = Math.min(base * CONFIG.gustSpeedBoost, CONFIG.windSpeedMax);
        setWindTarget(newAng, boosted);
      }

      // ease current wind toward target
      const k = Math.min(1, CONFIG.windEase * dt);
      state.wind.vx += (state.windTarget.vx - state.wind.vx) * k;
      state.wind.vy += (state.windTarget.vy - state.wind.vy) * k;

      // move the sheet in world PX (wind is in fog px/s → multiply by tile)
      if (state.sheet) {
        state.sheet.x += state.wind.vx * CONFIG.tile * dt;
        state.sheet.y += state.wind.vy * CONFIG.tile * dt;
      }

      // Carve holes under beam (in sheet pixel space, with wrap)
      clearMiasmaWithBeam();

      // NOTE: no respawn needed; we draw tiled with wrap now.
      // maybeRespawnSheet(); // <-- removed
    }

    // ---------------------------------------
    // Draw
    // ---------------------------------------
    function drawWorld() {
      ctx.save();
      // clip to circular world centered at (0,0)
      ctx.beginPath();
      ctx.arc(canvas.width/2 - state.cam.x, canvas.height/2 - state.cam.y, CONFIG.worldRadius, 0, Math.PI*2);
      ctx.clip();

      // ground fill
      const worldLeft = -CONFIG.worldRadius - state.cam.x + canvas.width/2;
      const worldTop  = -CONFIG.worldRadius - state.cam.y + canvas.height/2;
      const worldSize = CONFIG.worldRadius * 2;
      ctx.fillStyle = CONFIG.groundColor;
      ctx.fillRect(worldLeft, worldTop, worldSize, worldSize);

      // draw the drifting sheet as a seamless tile (wrap)
      if (state.sheet) {
        ctx.imageSmoothingEnabled = false;

        const tileW = state.sheet.w;
        const tileH = state.sheet.h;

        // offset sheet position relative to camera, wrapped into [0,tile)
        const baseDx = ((state.sheet.x - state.cam.x + canvas.width  / 2) % tileW + tileW) % tileW;
        const baseDy = ((state.sheet.y - state.cam.y + canvas.height / 2) % tileH + tileH) % tileH;

        // draw a 3×3 grid around the base tile to cover the world circle
        for (let oy = -1; oy <= 1; oy++) {
          for (let ox = -1; ox <= 1; ox++) {
            const dx = baseDx + ox * tileW;
            const dy = baseDy + oy * tileH;
            ctx.drawImage(
              state.sheetCanvas,
              0, 0, sheetFogSize, sheetFogSize,
              dx, dy, tileW, tileH
            );
          }
        }

        if (CONFIG.debug.showSheetBounds) {
          ctx.strokeStyle = "magenta";
          ctx.lineWidth = 2;
          ctx.strokeRect(baseDx, baseDy, tileW, tileH);
        }
      }

      ctx.restore();

      // Border ring
      ctx.beginPath();
      ctx.arc(canvas.width/2 - state.cam.x, canvas.height/2 - state.cam.y, CONFIG.worldRadius, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 4;
      ctx.stroke();
    }

    function drawPlayer() {
      const cx = canvas.width / 2, cy = canvas.height / 2;
      ctx.beginPath();
      ctx.arc(cx, cy, CONFIG.playerRadius, 0, Math.PI * 2);
      ctx.fillStyle = "#f5f5f5";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.stroke();
    }

    function drawBeam() {
      if (!state.beam.on) return;
      const cx = canvas.width/2, cy = canvas.height/2;
      const a = state.beam.aimAngle, ha = state.beam.halfAngle;

      if (state.beam.mode === "laser") {
        const r = state.beam.effectiveRange;
        const lx = cx + Math.cos(a) * r, ly = cy + Math.sin(a) * r;

        // Glow
        ctx.save();
        ctx.globalAlpha = CONFIG.laserGlowAlpha;
        ctx.lineWidth = CONFIG.laserGlowWidth;
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(lx, ly); ctx.stroke();
        ctx.restore();

        // Core
        ctx.lineWidth = CONFIG.laserWidth;
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(lx, ly); ctx.stroke();

        // Sparkle
        const time = state.time * 6;
        ctx.save();
        ctx.translate(lx, ly);
        ctx.rotate(time * 0.5);
        ctx.globalAlpha = CONFIG.sparkleAlpha * (0.7 + 0.3 * Math.sin(time));
        ctx.strokeStyle = CONFIG.beamEdge;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const ang = i * Math.PI / 3;
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(ang) * CONFIG.sparkleSize, Math.sin(ang) * CONFIG.sparkleSize);
        }
        ctx.stroke();
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = CONFIG.beamEdge;
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return;
      }

      if (state.beam.mode === "bubble") {
        const br = state.beam.bubbleR; if (br <= 0.5) return;
        ctx.beginPath(); ctx.arc(cx, cy, br, 0, Math.PI * 2);
        ctx.fillStyle = CONFIG.bubbleFill; ctx.fill();
        ctx.lineWidth = CONFIG.bubbleEdgeWidth;
        ctx.strokeStyle = CONFIG.bubbleEdge; ctx.stroke();
        return;
      }

      // Cone
      const r = state.beam.effectiveRange, a0 = a - ha, a1 = a + ha;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, r, a0, a1);
      ctx.closePath(); ctx.fillStyle = CONFIG.beamFill; ctx.fill();
      ctx.lineWidth = CONFIG.beamEdgeWidth; ctx.strokeStyle = CONFIG.beamEdge;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a0)*r, cy + Math.sin(a0)*r);
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a1)*r, cy + Math.sin(a1)*r);
      ctx.stroke();
      ctx.beginPath(); ctx.arc(cx, cy, r, a0, a1); ctx.stroke();
    }

    function drawHUD() {
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "12px monospace"; ctx.textBaseline = "top";
      const fps = Math.round(1 / Math.max(0.0001, state.dt));
      const totalDeg = toDeg(state.beam.halfAngle * 2);
      ctx.fillText(`FPS: ${fps}`, 8, 8);
      ctx.fillText(`CAM: (${state.cam.x.toFixed(1)}, ${state.cam.y.toFixed(1)})`, 8, 24);
      let mode = state.beam.mode.toUpperCase(), extra="";
      if (mode==="BUBBLE") extra=` | R=${Math.max(0, state.beam.bubbleR).toFixed(0)}`;
      if (mode==="CONE")   extra=` | range=${state.beam.effectiveRange.toFixed(0)}`;
      if (mode==="LASER")  extra=` | range=${state.beam.effectiveRange.toFixed(0)}`;
      ctx.fillText(`Mode: ${mode} | width=${totalDeg.toFixed(0)}°${extra}`, 8, 40);

      const spd = Math.hypot(state.wind.vx, state.wind.vy);
      const angDeg = toDeg(Math.atan2(state.wind.vy, state.wind.vx));
      ctx.fillText(`Wind: ${spd.toFixed(2)} px/s @ ${Math.round((angDeg+360)%360)}°`, 8, 56);
    }

    // ---------------------------------------
    // Main loop
    // ---------------------------------------
    let last = performance.now();
    function loop(now) {
      state.dt = (now - last) / 1000; last = now;
      state.time += state.dt;

      update(state.dt);

      ctx.fillStyle = CONFIG.bgColor;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      drawWorld();
      drawBeam();
      drawPlayer();
      drawHUD();

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ---------------------------------------
    // Clear miasma in SHEET PIXEL SPACE (with WRAP)
    // ---------------------------------------
    function clearMiasmaWithBeam() {
      if (!state.sheet) return;

      const hb = getBeamHitbox();
      if (!hb) return;

      const tile = CONFIG.tile;

      // visible area bounds in SHEET coordinates (unwrapped; can be any integer)
      const startCol = Math.floor(((state.cam.x - canvas.width/2) - state.sheet.x) / tile);
      const startRow = Math.floor(((state.cam.y - canvas.height/2) - state.sheet.y) / tile);
      const endCol   = Math.floor(((state.cam.x + canvas.width/2) - state.sheet.x) / tile) + 1;
      const endRow   = Math.floor(((state.cam.y + canvas.height/2) - state.sheet.y) / tile) + 1;

      const img = state.sheetImageData.data;
      let any = false;

      for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
          // wrap indices into [0, sheetFogSize)
          const wrapRow = ((row % sheetFogSize) + sheetFogSize) % sheetFogSize;
          const wrapCol = ((col % sheetFogSize) + sheetFogSize) % sheetFogSize;

          // world center for this fog pixel (use *unwrapped* row/col for position)
          const worldX = state.sheet.x + col * tile + tile / 2;
          const worldY = state.sheet.y + row * tile + tile / 2;

          // world → screen for hit test
          const sx = worldX - state.cam.x + canvas.width / 2;
          const sy = worldY - state.cam.y + canvas.height / 2;

          if (!pointInBeam(sx, sy)) continue;

          const idx = (wrapRow * sheetFogSize + wrapCol) * 4;
          if (img[idx + 3] === 0) continue; // already clear
          img[idx + 3] = 0; // alpha clear
          any = true;
        }
      }

      if (any) state.sheetCtx.putImageData(state.sheetImageData, 0, 0);
    }

    // ---------------------------------------
    // (No longer used) Despawn/respawn logic for finite sheet
    // ---------------------------------------
    function maybeRespawnSheet() {
      // kept for reference; not called in seamless wrap mode
    }

    // ---------------------------------------
    // Beam Hitbox + Collision
    // ---------------------------------------
    function getBeamHitbox() {
      const cx = canvas.width/2, cy = canvas.height/2;
      const a = state.beam.aimAngle, ha = state.beam.halfAngle;

      if (state.beam.mode === "laser") {
        const r = state.beam.effectiveRange;
        const lx = cx + Math.cos(a) * r;
        const ly = cy + Math.sin(a) * r;
        return { type: "line", x1: cx, y1: cy, x2: lx, y2: ly, radius: CONFIG.laserGlowWidth * 1 };
      }
      if (state.beam.mode === "bubble") {
        return { type:"circle", x:cx, y:cy, r: state.beam.bubbleR };
      }
      if (state.beam.mode === "cone") {
        const r = state.beam.effectiveRange;
        return { type:"cone", x:cx, y:cy, r, a0: a - ha, a1: a + ha };
      }
    }

    function pointInBeam(x, y) {
      const hb = getBeamHitbox();
      if (!hb) return false;

      if (hb.type === "circle") {
        return ((x-hb.x)**2 + (y-hb.y)**2 <= hb.r**2);
      }
      if (hb.type === "line") {
        const dx = hb.x2 - hb.x1, dy = hb.y2 - hb.y1;
        const t = Math.max(0, Math.min(1, ((x-hb.x1)*dx + (y-hb.y1)*dy) / (dx*dx+dy*dy)));
        const px = hb.x1 + t*dx, py = hb.y1 + t*dy;
        const dist2 = (x-px)**2 + (y-py)**2;
        return dist2 <= hb.radius**2;
      }
      if (hb.type === "cone") {
        const dx = x - hb.x, dy = y - hb.y;
        const dist2 = dx*dx + dy*dy;
        if (dist2 > hb.r*hb.r) return false;
        const ang = Math.atan2(dy, dx);
        let diff = ang - hb.a0;
        while (diff < 0) diff += Math.PI*2;
        const arc = (hb.a1 - hb.a0 + Math.PI*2) % (Math.PI*2);
        return diff <= arc;
      }
    }

    // ---------------------------------------
    // Utils
    // ---------------------------------------
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
    function toRad(deg){ return deg * Math.PI / 180; }
    function toDeg(rad){ return rad * 180 / Math.PI; }
    function lerp(a,b,t){ return a + (b-a) * t; }
    function randRange(a,b){ return a + Math.random() * (b - a); }
    function randInt(a,b){ return Math.floor(randRange(a, b+1)); }
    function randomAngle(){ return Math.random() * Math.PI * 2; }
    function unitFromAngle(a){ return { x: Math.cos(a), y: Math.sin(a) }; }

  </script>
</body>
</html>
